#!/usr/bin/env python3
"""
Email Task Manager Integration Agent
Third-party service integrations (calendars, Slack, task managers)
"""

import os
import json
import requests
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from pathlib import Path
import base64

class EmailTaskIntegrationManager:
    """Third-party integration management for Email Task Manager"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.backend_path = self.project_root / "backend"
        self.integrations_dir = self.backend_path / "integrations"
        
        self.integration_results = {
            'calendar_integrations': [],
            'slack_integrations': [],
            'task_manager_integrations': [],
            'webhook_handlers': [],
            'sync_services': []
        }
        
        # Integration configurations
        self.supported_integrations = {
            'google_calendar': {
                'name': 'Google Calendar',
                'type': 'calendar',
                'auth': 'oauth2',
                'scopes': ['https://www.googleapis.com/auth/calendar']
            },
            'slack': {
                'name': 'Slack',
                'type': 'messaging',
                'auth': 'oauth2',
                'scopes': ['chat:write', 'channels:read']
            },
            'trello': {
                'name': 'Trello',
                'type': 'task_manager',
                'auth': 'api_key',
                'scopes': ['read', 'write']
            },
            'todoist': {
                'name': 'Todoist',
                'type': 'task_manager',
                'auth': 'api_token',
                'scopes': ['data:read_write']
            }
        }
    
    def setup_complete_integrations(self) -> Dict[str, Any]:
        """Set up complete integration infrastructure"""
        print("üîó Setting up Email Task Manager Integrations...")
        
        # Create integration infrastructure
        self._create_integration_framework()
        self._build_calendar_integrations()
        self._build_slack_integrations()
        self._build_task_manager_integrations()
        self._create_webhook_system()
        self._create_sync_services()
        
        # Integration management tools
        self._create_integration_manager()
        self._create_monitoring_tools()
        
        return self._generate_integration_report()
    
    def _create_integration_framework(self):
        """Create base integration framework"""
        print("üèóÔ∏è Creating integration framework...")
        
        # Create integrations directory
        self.integrations_dir.mkdir(exist_ok=True)
        
        # Base integration class
        base_integration = """#!/usr/bin/env python3
\"\"\"
Base Integration Framework
Generated by Integration Manager Agent
\"\"\"

import json
import requests
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Dict, List, Any, Optional
from pathlib import Path
import sys
sys.path.append(str(Path(__file__).parent.parent.parent))

from backend import create_app, db

class BaseIntegration(ABC):
    \"\"\"Base class for all integrations\"\"\"
    
    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.config = config
        self.app = create_app()
        self.is_authenticated = False
        self.credentials = {}
    
    @abstractmethod
    def authenticate(self, credentials: Dict[str, Any]) -> bool:
        \"\"\"Authenticate with the service\"\"\"
        pass
    
    @abstractmethod
    def test_connection(self) -> Dict[str, Any]:
        \"\"\"Test connection to service\"\"\"
        pass
    
    @abstractmethod
    def sync_data(self, data: Any) -> Dict[str, Any]:
        \"\"\"Sync data to service\"\"\"
        pass
    
    def log_activity(self, action: str, result: Dict[str, Any]):
        \"\"\"Log integration activity\"\"\"
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'integration': self.name,
            'action': action,
            'result': result
        }
        
        log_file = Path(__file__).parent / 'integration_logs.json'
        logs = []
        
        if log_file.exists():
            try:
                with open(log_file, 'r') as f:
                    logs = json.load(f)
            except:
                logs = []
        
        logs.append(log_entry)
        
        # Keep only last 1000 entries
        logs = logs[-1000:]
        
        with open(log_file, 'w') as f:
            json.dump(logs, f, indent=2)
    
    def handle_rate_limit(self, response: requests.Response) -> bool:
        \"\"\"Handle rate limiting\"\"\"
        if response.status_code == 429:
            retry_after = response.headers.get('Retry-After', '60')
            print(f"Rate limited. Retry after {retry_after} seconds")
            return True
        return False
    
    def make_api_request(self, method: str, url: str, **kwargs) -> requests.Response:
        \"\"\"Make authenticated API request\"\"\"
        if not self.is_authenticated:
            raise Exception(f"{self.name} not authenticated")
        
        # Add authentication headers
        if 'headers' not in kwargs:
            kwargs['headers'] = {}
        
        kwargs['headers'].update(self._get_auth_headers())
        
        response = requests.request(method, url, **kwargs)
        
        if self.handle_rate_limit(response):
            return response
        
        return response
    
    @abstractmethod
    def _get_auth_headers(self) -> Dict[str, str]:
        \"\"\"Get authentication headers\"\"\"
        pass

class IntegrationManager:
    \"\"\"Manage all integrations\"\"\"
    
    def __init__(self):
        self.integrations = {}
        self.config_file = Path(__file__).parent / 'integrations_config.json'
        self._load_config()
    
    def register_integration(self, integration: BaseIntegration):
        \"\"\"Register an integration\"\"\"
        self.integrations[integration.name] = integration
    
    def get_integration(self, name: str) -> Optional[BaseIntegration]:
        \"\"\"Get integration by name\"\"\"
        return self.integrations.get(name)
    
    def test_all_integrations(self) -> Dict[str, Dict[str, Any]]:
        \"\"\"Test all registered integrations\"\"\"
        results = {}
        
        for name, integration in self.integrations.items():
            try:
                result = integration.test_connection()
                results[name] = result
            except Exception as e:
                results[name] = {'error': str(e), 'status': 'failed'}
        
        return results
    
    def _load_config(self):
        \"\"\"Load integration configuration\"\"\"
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                self.config = json.load(f)
        else:
            self.config = {}

# Global integration manager instance
integration_manager = IntegrationManager()
"""
        
        base_integration_file = self.integrations_dir / "base_integration.py"
        with open(base_integration_file, 'w') as f:
            f.write(base_integration)
        
        self.integration_results['webhook_handlers'].append({
            'type': 'Base Integration Framework',
            'file': str(base_integration_file),
            'features': 'Abstract base class, authentication, rate limiting, logging',
            'usage': 'Base class for all integrations'
        })
    
    def _build_calendar_integrations(self):
        """Build calendar integration capabilities"""
        print("üìÖ Building calendar integrations...")
        
        calendar_integration = """#!/usr/bin/env python3
\"\"\"
Google Calendar Integration
Generated by Integration Manager Agent
\"\"\"

import json
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from pathlib import Path
import sys
sys.path.append(str(Path(__file__).parent.parent.parent))

from backend import create_app, db
from backend.models.task import Task
from backend.integrations.base_integration import BaseIntegration

class GoogleCalendarIntegration(BaseIntegration):
    \"\"\"Google Calendar integration\"\"\"
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__('google_calendar', config)
        self.calendar_id = config.get('calendar_id', 'primary')
    
    def authenticate(self, credentials: Dict[str, Any]) -> bool:
        \"\"\"Authenticate with Google Calendar\"\"\"
        try:
            self.credentials = credentials
            self.is_authenticated = True
            
            # Test authentication with a simple API call
            result = self.test_connection()
            return result.get('status') == 'success'
            
        except Exception as e:
            self.log_activity('authenticate', {'error': str(e)})
            return False
    
    def test_connection(self) -> Dict[str, Any]:
        \"\"\"Test Google Calendar connection\"\"\"
        try:
            response = self.make_api_request(
                'GET',
                f'https://www.googleapis.com/calendar/v3/calendars/{self.calendar_id}'
            )
            
            if response.status_code == 200:
                return {'status': 'success', 'calendar': response.json()}
            else:
                return {'status': 'error', 'message': response.text}
                
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def sync_data(self, task_data: Any) -> Dict[str, Any]:
        \"\"\"Sync task to Google Calendar as event\"\"\"
        if isinstance(task_data, Task):
            return self.create_calendar_event_from_task(task_data)
        else:
            return {'error': 'Invalid task data'}
    
    def create_calendar_event_from_task(self, task: Task) -> Dict[str, Any]:
        \"\"\"Create calendar event from task\"\"\"
        try:
            event_data = {
                'summary': f"Task: {task.description}",
                'description': f"Email Task - Priority: {task.priority}\\nCategory: {task.category}",
                'start': {
                    'dateTime': (datetime.now() + timedelta(hours=1)).isoformat(),
                    'timeZone': 'UTC'
                },
                'end': {
                    'dateTime': (datetime.now() + timedelta(hours=2)).isoformat(),
                    'timeZone': 'UTC'
                },
                'reminders': {
                    'useDefault': False,
                    'overrides': [
                        {'method': 'email', 'minutes': 15},
                        {'method': 'popup', 'minutes': 5}
                    ]
                }
            }
            
            response = self.make_api_request(
                'POST',
                f'https://www.googleapis.com/calendar/v3/calendars/{self.calendar_id}/events',
                json=event_data
            )
            
            if response.status_code == 200:
                event = response.json()
                self.log_activity('create_event', {'task_id': task.id, 'event_id': event['id']})
                return {'status': 'success', 'event_id': event['id']}
            else:
                return {'status': 'error', 'message': response.text}
                
        except Exception as e:
            self.log_activity('create_event', {'error': str(e)})
            return {'status': 'error', 'message': str(e)}
    
    def get_upcoming_events(self, days: int = 7) -> List[Dict[str, Any]]:
        \"\"\"Get upcoming calendar events\"\"\"
        try:
            time_min = datetime.now().isoformat() + 'Z'
            time_max = (datetime.now() + timedelta(days=days)).isoformat() + 'Z'
            
            response = self.make_api_request(
                'GET',
                f'https://www.googleapis.com/calendar/v3/calendars/{self.calendar_id}/events',
                params={
                    'timeMin': time_min,
                    'timeMax': time_max,
                    'singleEvents': True,
                    'orderBy': 'startTime'
                }
            )
            
            if response.status_code == 200:
                return response.json().get('items', [])
            else:
                return []
                
        except Exception as e:
            self.log_activity('get_events', {'error': str(e)})
            return []
    
    def _get_auth_headers(self) -> Dict[str, str]:
        \"\"\"Get Google API authentication headers\"\"\"
        access_token = self.credentials.get('access_token')
        return {'Authorization': f'Bearer {access_token}'}

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Google Calendar Integration')
    parser.add_argument('--test', action='store_true', help='Test connection')
    parser.add_argument('--sync-task', type=int, help='Sync task ID to calendar')
    parser.add_argument('--events', action='store_true', help='Get upcoming events')
    
    args = parser.parse_args()
    
    # Load config (would come from environment or config file)
    config = {'calendar_id': 'primary'}
    integration = GoogleCalendarIntegration(config)
    
    # Mock credentials for testing
    credentials = {'access_token': 'mock_token'}
    integration.authenticate(credentials)
    
    if args.test:
        result = integration.test_connection()
        print(f"Connection test: {result}")
    
    if args.events:
        events = integration.get_upcoming_events()
        print(f"Upcoming events: {len(events)}")

if __name__ == "__main__":
    main()
"""
        
        calendar_file = self.integrations_dir / "google_calendar.py"
        with open(calendar_file, 'w') as f:
            f.write(calendar_integration)
        
        try:
            os.chmod(calendar_file, 0o755)
        except:
            pass
        
        self.integration_results['calendar_integrations'].append({
            'type': 'Google Calendar Integration',
            'file': str(calendar_file),
            'features': 'Task-to-event sync, upcoming events, authentication',
            'usage': 'python google_calendar.py --test --sync-task 1 --events'
        })
    
    def _build_slack_integrations(self):
        """Build Slack integration capabilities"""
        print("üí¨ Building Slack integrations...")
        
        slack_integration = """#!/usr/bin/env python3
\"\"\"
Slack Integration
Generated by Integration Manager Agent
\"\"\"

import json
from typing import Dict, List, Any, Optional
from pathlib import Path
import sys
sys.path.append(str(Path(__file__).parent.parent.parent))

from backend import create_app, db
from backend.models.task import Task
from backend.integrations.base_integration import BaseIntegration

class SlackIntegration(BaseIntegration):
    \"\"\"Slack integration for notifications and task management\"\"\"
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__('slack', config)
        self.default_channel = config.get('default_channel', '#email-tasks')
        self.bot_token = config.get('bot_token')
    
    def authenticate(self, credentials: Dict[str, Any]) -> bool:
        \"\"\"Authenticate with Slack\"\"\"
        try:
            self.credentials = credentials
            self.bot_token = credentials.get('bot_token')
            self.is_authenticated = True
            
            # Test authentication
            result = self.test_connection()
            return result.get('status') == 'success'
            
        except Exception as e:
            self.log_activity('authenticate', {'error': str(e)})
            return False
    
    def test_connection(self) -> Dict[str, Any]:
        \"\"\"Test Slack connection\"\"\"
        try:
            response = self.make_api_request(
                'POST',
                'https://slack.com/api/auth.test'
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('ok'):
                    return {'status': 'success', 'team': data.get('team'), 'user': data.get('user')}
                else:
                    return {'status': 'error', 'message': data.get('error')}
            else:
                return {'status': 'error', 'message': response.text}
                
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def sync_data(self, task_data: Any) -> Dict[str, Any]:
        \"\"\"Send task notification to Slack\"\"\"
        if isinstance(task_data, Task):
            return self.send_task_notification(task_data)
        else:
            return {'error': 'Invalid task data'}
    
    def send_task_notification(self, task: Task, channel: Optional[str] = None) -> Dict[str, Any]:
        \"\"\"Send task notification to Slack channel\"\"\"
        try:
            channel = channel or self.default_channel
            
            # Create rich message with task details
            message_blocks = [
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"üìß *New Email Task*\\n*{task.description}*"
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*Priority:*\\n{task.priority}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Category:*\\n{task.category or 'None'}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Created:*\\n{task.created_at.strftime('%Y-%m-%d %H:%M') if task.created_at else 'Unknown'}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Status:*\\n{'‚úÖ Complete' if task.completed else '‚è≥ Pending'}"
                        }
                    ]
                }
            ]
            
            # Add action buttons
            if not task.completed:
                message_blocks.append({
                    "type": "actions",
                    "elements": [
                        {
                            "type": "button",
                            "text": {
                                "type": "plain_text",
                                "text": "Mark Complete"
                            },
                            "style": "primary",
                            "value": f"complete_{task.id}"
                        },
                        {
                            "type": "button",
                            "text": {
                                "type": "plain_text",
                                "text": "View Details"
                            },
                            "value": f"details_{task.id}"
                        }
                    ]
                })
            
            response = self.make_api_request(
                'POST',
                'https://slack.com/api/chat.postMessage',
                json={
                    'channel': channel,
                    'blocks': message_blocks
                }
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('ok'):
                    self.log_activity('send_notification', {
                        'task_id': task.id,
                        'channel': channel,
                        'message_ts': data.get('ts')
                    })
                    return {'status': 'success', 'message_ts': data.get('ts')}
                else:
                    return {'status': 'error', 'message': data.get('error')}
            else:
                return {'status': 'error', 'message': response.text}
                
        except Exception as e:
            self.log_activity('send_notification', {'error': str(e)})
            return {'status': 'error', 'message': str(e)}
    
    def send_daily_summary(self, user_id: int, channel: Optional[str] = None) -> Dict[str, Any]:
        \"\"\"Send daily task summary to Slack\"\"\"
        try:
            with self.app.app_context():
                # Get today's tasks
                from datetime import date
                today = date.today()
                
                tasks = Task.query.filter(
                    Task.user_id == user_id,
                    Task.created_at >= today
                ).all()
                
                completed = sum(1 for task in tasks if task.completed)
                pending = len(tasks) - completed
                
                summary_text = f"üìä *Daily Task Summary*\\n"
                summary_text += f"Total: {len(tasks)} | ‚úÖ Completed: {completed} | ‚è≥ Pending: {pending}"
                
                if pending > 0:
                    summary_text += "\\n\\n*Pending Tasks:*"
                    for task in tasks:
                        if not task.completed:
                            priority_emoji = {'High': 'üî¥', 'Medium': 'üü°', 'Low': 'üü¢'}.get(task.priority, '‚ö™')
                            summary_text += f"\\n{priority_emoji} {task.description[:50]}..."
                
                response = self.make_api_request(
                    'POST',
                    'https://slack.com/api/chat.postMessage',
                    json={
                        'channel': channel or self.default_channel,
                        'text': summary_text
                    }
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('ok'):
                        return {'status': 'success', 'summary_sent': True}
                    else:
                        return {'status': 'error', 'message': data.get('error')}
                else:
                    return {'status': 'error', 'message': response.text}
                    
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def _get_auth_headers(self) -> Dict[str, str]:
        \"\"\"Get Slack API authentication headers\"\"\"
        return {'Authorization': f'Bearer {self.bot_token}'}

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Slack Integration')
    parser.add_argument('--test', action='store_true', help='Test connection')
    parser.add_argument('--notify-task', type=int, help='Send task notification')
    parser.add_argument('--daily-summary', type=int, help='Send daily summary for user')
    parser.add_argument('--channel', type=str, help='Slack channel')
    
    args = parser.parse_args()
    
    # Load config
    config = {
        'default_channel': '#email-tasks',
        'bot_token': 'mock_token'
    }
    integration = SlackIntegration(config)
    
    credentials = {'bot_token': 'mock_token'}
    integration.authenticate(credentials)
    
    if args.test:
        result = integration.test_connection()
        print(f"Connection test: {result}")
    
    if args.daily_summary:
        result = integration.send_daily_summary(args.daily_summary, args.channel)
        print(f"Daily summary: {result}")

if __name__ == "__main__":
    main()
"""
        
        slack_file = self.integrations_dir / "slack_integration.py"
        with open(slack_file, 'w') as f:
            f.write(slack_integration)
        
        try:
            os.chmod(slack_file, 0o755)
        except:
            pass
        
        self.integration_results['slack_integrations'].append({
            'type': 'Slack Integration',
            'file': str(slack_file),
            'features': 'Task notifications, daily summaries, rich message formatting',
            'usage': 'python slack_integration.py --test --notify-task 1 --daily-summary 1'
        })
    
    def _build_task_manager_integrations(self):
        """Build task manager integrations"""
        print("‚úÖ Building task manager integrations...")
        
        trello_integration = """#!/usr/bin/env python3
\"\"\"
Trello Integration
Generated by Integration Manager Agent
\"\"\"

import json
from typing import Dict, List, Any, Optional
from pathlib import Path
import sys
sys.path.append(str(Path(__file__).parent.parent.parent))

from backend import create_app, db
from backend.models.task import Task
from backend.integrations.base_integration import BaseIntegration

class TrelloIntegration(BaseIntegration):
    \"\"\"Trello integration for task management\"\"\"
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__('trello', config)
        self.board_id = config.get('board_id')
        self.list_id = config.get('list_id')  # Default list for new cards
        self.api_key = config.get('api_key')
        self.token = config.get('token')
    
    def authenticate(self, credentials: Dict[str, Any]) -> bool:
        \"\"\"Authenticate with Trello\"\"\"
        try:
            self.credentials = credentials
            self.api_key = credentials.get('api_key')
            self.token = credentials.get('token')
            self.is_authenticated = True
            
            # Test authentication
            result = self.test_connection()
            return result.get('status') == 'success'
            
        except Exception as e:
            self.log_activity('authenticate', {'error': str(e)})
            return False
    
    def test_connection(self) -> Dict[str, Any]:
        \"\"\"Test Trello connection\"\"\"
        try:
            response = self.make_api_request(
                'GET',
                f'https://api.trello.com/1/boards/{self.board_id}',
                params={'key': self.api_key, 'token': self.token}
            )
            
            if response.status_code == 200:
                board = response.json()
                return {'status': 'success', 'board': board['name']}
            else:
                return {'status': 'error', 'message': response.text}
                
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def sync_data(self, task_data: Any) -> Dict[str, Any]:
        \"\"\"Sync task to Trello as card\"\"\"
        if isinstance(task_data, Task):
            return self.create_trello_card_from_task(task_data)
        else:
            return {'error': 'Invalid task data'}
    
    def create_trello_card_from_task(self, task: Task) -> Dict[str, Any]:
        \"\"\"Create Trello card from email task\"\"\"
        try:
            card_data = {
                'name': task.description,
                'desc': f"Email Task\\nPriority: {task.priority}\\nCategory: {task.category or 'None'}\\nCreated: {task.created_at}",
                'idList': self.list_id,
                'key': self.api_key,
                'token': self.token
            }
            
            # Add labels based on priority
            priority_labels = {
                'High': 'red',
                'Medium': 'yellow', 
                'Low': 'green'
            }
            
            if task.priority in priority_labels:
                # Get board labels first
                labels_response = self.make_api_request(
                    'GET',
                    f'https://api.trello.com/1/boards/{self.board_id}/labels',
                    params={'key': self.api_key, 'token': self.token}
                )
                
                if labels_response.status_code == 200:
                    labels = labels_response.json()
                    priority_label = next((label for label in labels 
                                         if label['color'] == priority_labels[task.priority]), None)
                    if priority_label:
                        card_data['idLabels'] = priority_label['id']
            
            response = self.make_api_request(
                'POST',
                'https://api.trello.com/1/cards',
                data=card_data
            )
            
            if response.status_code == 200:
                card = response.json()
                self.log_activity('create_card', {'task_id': task.id, 'card_id': card['id']})
                return {'status': 'success', 'card_id': card['id'], 'url': card['url']}
            else:
                return {'status': 'error', 'message': response.text}
                
        except Exception as e:
            self.log_activity('create_card', {'error': str(e)})
            return {'status': 'error', 'message': str(e)}
    
    def get_board_lists(self) -> List[Dict[str, Any]]:
        \"\"\"Get all lists in the board\"\"\"
        try:
            response = self.make_api_request(
                'GET',
                f'https://api.trello.com/1/boards/{self.board_id}/lists',
                params={'key': self.api_key, 'token': self.token}
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                return []
                
        except Exception as e:
            self.log_activity('get_lists', {'error': str(e)})
            return []
    
    def _get_auth_headers(self) -> Dict[str, str]:
        \"\"\"Trello uses query parameters for auth\"\"\"
        return {}

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Trello Integration')
    parser.add_argument('--test', action='store_true', help='Test connection')
    parser.add_argument('--sync-task', type=int, help='Sync task ID to Trello')
    parser.add_argument('--lists', action='store_true', help='Get board lists')
    
    args = parser.parse_args()
    
    # Load config
    config = {
        'board_id': 'mock_board_id',
        'list_id': 'mock_list_id',
        'api_key': 'mock_api_key',
        'token': 'mock_token'
    }
    integration = TrelloIntegration(config)
    
    credentials = {
        'api_key': 'mock_api_key',
        'token': 'mock_token'
    }
    integration.authenticate(credentials)
    
    if args.test:
        result = integration.test_connection()
        print(f"Connection test: {result}")
    
    if args.lists:
        lists = integration.get_board_lists()
        print(f"Board lists: {[l['name'] for l in lists]}")

if __name__ == "__main__":
    main()
"""
        
        trello_file = self.integrations_dir / "trello_integration.py"
        with open(trello_file, 'w') as f:
            f.write(trello_integration)
        
        try:
            os.chmod(trello_file, 0o755)
        except:
            pass
        
        self.integration_results['task_manager_integrations'].append({
            'type': 'Trello Integration',
            'file': str(trello_file),
            'features': 'Task-to-card sync, priority labels, board management',
            'usage': 'python trello_integration.py --test --sync-task 1 --lists'
        })
    
    def _create_webhook_system(self):
        """Create webhook handling system"""
        print("üîó Creating webhook system...")
        
        webhook_handler = """#!/usr/bin/env python3
\"\"\"
Webhook Handler System
Generated by Integration Manager Agent
\"\"\"

import json
import hmac
import hashlib
from datetime import datetime
from typing import Dict, List, Any, Optional
from flask import Blueprint, request, jsonify
from pathlib import Path
import sys
sys.path.append(str(Path(__file__).parent.parent.parent))

from backend import db
from backend.models.task import Task

webhook_bp = Blueprint('webhooks', __name__, url_prefix='/webhooks')

class WebhookProcessor:
    \"\"\"Process incoming webhooks from various services\"\"\"
    
    def __init__(self):
        self.handlers = {
            'slack': self._handle_slack_webhook,
            'trello': self._handle_trello_webhook,
            'calendar': self._handle_calendar_webhook
        }
    
    def process_webhook(self, service: str, payload: Dict[str, Any], headers: Dict[str, str]) -> Dict[str, Any]:
        \"\"\"Process incoming webhook\"\"\"
        if service not in self.handlers:
            return {'error': f'Unsupported service: {service}'}
        
        try:
            # Verify webhook if needed
            if not self._verify_webhook(service, payload, headers):
                return {'error': 'Webhook verification failed'}
            
            return self.handlers[service](payload, headers)
            
        except Exception as e:
            return {'error': str(e)}
    
    def _verify_webhook(self, service: str, payload: Dict[str, Any], headers: Dict[str, str]) -> bool:
        \"\"\"Verify webhook authenticity\"\"\"
        # Implement service-specific verification
        if service == 'slack':
            return self._verify_slack_webhook(payload, headers)
        elif service == 'trello':
            return self._verify_trello_webhook(payload, headers)
        
        return True  # Default to true for services without verification
    
    def _verify_slack_webhook(self, payload: Dict[str, Any], headers: Dict[str, str]) -> bool:
        \"\"\"Verify Slack webhook signature\"\"\"
        slack_signing_secret = 'your_slack_signing_secret'  # Should come from config
        timestamp = headers.get('X-Slack-Request-Timestamp', '')
        signature = headers.get('X-Slack-Signature', '')
        
        if not timestamp or not signature:
            return False
        
        # Create signature
        sig_basestring = f"v0:{timestamp}:{json.dumps(payload)}"
        computed_signature = 'v0=' + hmac.new(
            slack_signing_secret.encode(),
            sig_basestring.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return hmac.compare_digest(computed_signature, signature)
    
    def _verify_trello_webhook(self, payload: Dict[str, Any], headers: Dict[str, str]) -> bool:
        \"\"\"Verify Trello webhook\"\"\"
        # Trello webhook verification logic
        return True  # Simplified for example
    
    def _handle_slack_webhook(self, payload: Dict[str, Any], headers: Dict[str, str]) -> Dict[str, Any]:
        \"\"\"Handle Slack webhook events\"\"\"
        event_type = payload.get('type')
        
        if event_type == 'interactive_message':
            return self._handle_slack_interaction(payload)
        elif event_type == 'event_callback':
            return self._handle_slack_event(payload)
        
        return {'status': 'ignored'}
    
    def _handle_slack_interaction(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        \"\"\"Handle Slack interactive message (button clicks)\"\"\"
        actions = payload.get('actions', [])
        
        for action in actions:
            if action.get('value', '').startswith('complete_'):
                task_id = int(action['value'].split('_')[1])
                return self._complete_task(task_id)
            elif action.get('value', '').startswith('details_'):
                task_id = int(action['value'].split('_')[1])
                return self._get_task_details(task_id)
        
        return {'status': 'no_action'}
    
    def _handle_slack_event(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        \"\"\"Handle Slack events\"\"\"
        event = payload.get('event', {})
        event_type = event.get('type')
        
        if event_type == 'message':
            # Handle direct messages or mentions
            return self._handle_slack_message(event)
        
        return {'status': 'ignored'}
    
    def _handle_slack_message(self, event: Dict[str, Any]) -> Dict[str, Any]:
        \"\"\"Handle Slack message events\"\"\"
        text = event.get('text', '').lower()
        
        if 'task summary' in text:
            # User requested task summary
            return {'action': 'send_summary', 'channel': event.get('channel')}
        
        return {'status': 'ignored'}
    
    def _handle_trello_webhook(self, payload: Dict[str, Any], headers: Dict[str, str]) -> Dict[str, Any]:
        \"\"\"Handle Trello webhook events\"\"\"
        action = payload.get('action', {})
        action_type = action.get('type')
        
        if action_type == 'updateCard':
            return self._handle_trello_card_update(action)
        elif action_type == 'createCard':
            return self._handle_trello_card_create(action)
        
        return {'status': 'ignored'}
    
    def _handle_trello_card_update(self, action: Dict[str, Any]) -> Dict[str, Any]:
        \"\"\"Handle Trello card updates\"\"\"
        card = action.get('data', {}).get('card', {})
        
        # If card is moved to "Done" list, mark corresponding task as complete
        if action.get('data', {}).get('listAfter', {}).get('name', '').lower() == 'done':
            # Find task by card reference (would need to store this mapping)
            return {'action': 'mark_complete', 'card_id': card.get('id')}
        
        return {'status': 'updated'}
    
    def _handle_trello_card_create(self, action: Dict[str, Any]) -> Dict[str, Any]:
        \"\"\"Handle Trello card creation\"\"\"
        return {'status': 'created'}
    
    def _handle_calendar_webhook(self, payload: Dict[str, Any], headers: Dict[str, str]) -> Dict[str, Any]:
        \"\"\"Handle Google Calendar webhook events\"\"\"
        # Handle calendar event changes
        return {'status': 'processed'}
    
    def _complete_task(self, task_id: int) -> Dict[str, Any]:
        \"\"\"Mark task as complete\"\"\"
        task = Task.query.get(task_id)
        if task:
            task.completed = True
            task.completed_at = datetime.now()
            db.session.commit()
            return {'status': 'completed', 'task_id': task_id}
        
        return {'error': 'Task not found'}
    
    def _get_task_details(self, task_id: int) -> Dict[str, Any]:
        \"\"\"Get task details\"\"\"
        task = Task.query.get(task_id)
        if task:
            return {'status': 'found', 'task': task.to_dict()}
        
        return {'error': 'Task not found'}

# Global webhook processor
webhook_processor = WebhookProcessor()

@webhook_bp.route('/<service>', methods=['POST'])
def handle_webhook(service: str):
    \"\"\"Handle incoming webhooks\"\"\"
    payload = request.get_json() or {}
    headers = dict(request.headers)
    
    result = webhook_processor.process_webhook(service, payload, headers)
    
    return jsonify(result)

@webhook_bp.route('/test/<service>', methods=['GET'])
def test_webhook(service: str):
    \"\"\"Test webhook endpoint\"\"\"
    return jsonify({
        'service': service,
        'status': 'webhook endpoint active',
        'timestamp': datetime.now().isoformat()
    })
"""
        
        webhook_file = self.integrations_dir / "webhook_handler.py"
        with open(webhook_file, 'w') as f:
            f.write(webhook_handler)
        
        self.integration_results['webhook_handlers'].append({
            'type': 'Webhook Handler System',
            'file': str(webhook_file),
            'features': 'Multi-service webhooks, signature verification, event processing',
            'usage': 'Flask blueprint for handling webhooks at /webhooks/<service>'
        })
    
    def _create_sync_services(self):
        """Create data synchronization services"""
        print("üîÑ Creating sync services...")
        
        sync_service = """#!/usr/bin/env python3
\"\"\"
Integration Sync Service
Generated by Integration Manager Agent
\"\"\"

import json
import time
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from pathlib import Path
import sys
sys.path.append(str(Path(__file__).parent.parent.parent))

from backend import create_app, db
from backend.models.task import Task
from backend.integrations.base_integration import integration_manager

class SyncService:
    \"\"\"Manage data synchronization with external services\"\"\"
    
    def __init__(self):
        self.app = create_app()
        self.sync_interval = 300  # 5 minutes
        self.is_running = False
        self.sync_thread = None
        self.last_sync = {}
    
    def start_sync(self):
        \"\"\"Start background sync service\"\"\"
        if self.is_running:
            return
        
        self.is_running = True
        self.sync_thread = threading.Thread(target=self._sync_loop, daemon=True)
        self.sync_thread.start()
        print("Sync service started")
    
    def stop_sync(self):
        \"\"\"Stop background sync service\"\"\"
        self.is_running = False
        if self.sync_thread:
            self.sync_thread.join()
        print("Sync service stopped")
    
    def _sync_loop(self):
        \"\"\"Main sync loop\"\"\"
        while self.is_running:
            try:
                self._perform_sync()
                time.sleep(self.sync_interval)
            except Exception as e:
                print(f"Sync error: {e}")
                time.sleep(60)  # Wait 1 minute on error
    
    def _perform_sync(self):
        \"\"\"Perform synchronization with all active integrations\"\"\"
        with self.app.app_context():
            # Get recently created/updated tasks
            cutoff_time = datetime.now() - timedelta(minutes=self.sync_interval // 60 + 1)
            
            tasks = Task.query.filter(
                Task.created_at >= cutoff_time
            ).all()
            
            if not tasks:
                return
            
            # Sync with each integration
            for integration_name, integration in integration_manager.integrations.items():
                if not integration.is_authenticated:
                    continue
                
                try:
                    self._sync_tasks_with_integration(tasks, integration)
                    self.last_sync[integration_name] = datetime.now().isoformat()
                except Exception as e:
                    print(f"Error syncing with {integration_name}: {e}")
    
    def _sync_tasks_with_integration(self, tasks: List[Task], integration):
        \"\"\"Sync tasks with specific integration\"\"\"
        for task in tasks:
            # Skip if task was already synced with this integration
            if self._was_task_synced(task, integration.name):
                continue
            
            result = integration.sync_data(task)
            
            if result.get('status') == 'success':
                self._mark_task_synced(task, integration.name, result)
            else:
                print(f"Failed to sync task {task.id} with {integration.name}: {result}")
    
    def _was_task_synced(self, task: Task, integration_name: str) -> bool:
        \"\"\"Check if task was already synced with integration\"\"\"
        # This would check a sync status table or metadata field
        # For now, simplified implementation
        return False
    
    def _mark_task_synced(self, task: Task, integration_name: str, result: Dict[str, Any]):
        \"\"\"Mark task as synced with integration\"\"\"
        # This would store sync metadata
        # For now, just log the sync
        print(f"Task {task.id} synced with {integration_name}: {result}")
    
    def manual_sync(self, task_id: int, integration_names: List[str] = None) -> Dict[str, Any]:
        \"\"\"Manually sync specific task\"\"\"
        with self.app.app_context():
            task = Task.query.get(task_id)
            if not task:
                return {'error': 'Task not found'}
            
            results = {}
            target_integrations = integration_names or list(integration_manager.integrations.keys())
            
            for integration_name in target_integrations:
                integration = integration_manager.get_integration(integration_name)
                if not integration or not integration.is_authenticated:
                    results[integration_name] = {'error': 'Integration not available'}
                    continue
                
                try:
                    result = integration.sync_data(task)
                    results[integration_name] = result
                    
                    if result.get('status') == 'success':
                        self._mark_task_synced(task, integration_name, result)
                        
                except Exception as e:
                    results[integration_name] = {'error': str(e)}
            
            return results
    
    def get_sync_status(self) -> Dict[str, Any]:
        \"\"\"Get current sync status\"\"\"
        return {
            'is_running': self.is_running,
            'sync_interval': self.sync_interval,
            'last_sync': self.last_sync,
            'active_integrations': len([
                name for name, integration in integration_manager.integrations.items()
                if integration.is_authenticated
            ])
        }

# Global sync service instance
sync_service = SyncService()

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Integration Sync Service')
    parser.add_argument('--start', action='store_true', help='Start sync service')
    parser.add_argument('--stop', action='store_true', help='Stop sync service')
    parser.add_argument('--status', action='store_true', help='Get sync status')
    parser.add_argument('--manual-sync', type=int, help='Manually sync task ID')
    
    args = parser.parse_args()
    
    if args.start:
        sync_service.start_sync()
        print("Sync service is running. Press Ctrl+C to stop.")
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            sync_service.stop_sync()
    
    elif args.stop:
        sync_service.stop_sync()
    
    elif args.status:
        status = sync_service.get_sync_status()
        print(json.dumps(status, indent=2))
    
    elif args.manual_sync:
        result = sync_service.manual_sync(args.manual_sync)
        print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
"""
        
        sync_file = self.integrations_dir / "sync_service.py"
        with open(sync_file, 'w') as f:
            f.write(sync_service)
        
        try:
            os.chmod(sync_file, 0o755)
        except:
            pass
        
        self.integration_results['sync_services'].append({
            'type': 'Integration Sync Service',
            'file': str(sync_file),
            'features': 'Background sync, manual sync, status monitoring',
            'usage': 'python sync_service.py --start --status --manual-sync 1'
        })
    
    def _create_integration_manager(self):
        """Create integration management tools"""
        print("‚öôÔ∏è Creating integration management tools...")
        
        # Create orchestration script
        orchestration_script = """#!/bin/bash
# Integration Management Script
# Generated by Integration Manager Agent

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BACKEND_DIR="$(dirname "$SCRIPT_DIR")"
INTEGRATIONS_DIR="$BACKEND_DIR/integrations"

# Colors
GREEN='\\033[0;32m'
BLUE='\\033[0;34m'
YELLOW='\\033[1;33m'
NC='\\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Test all integrations
test_integrations() {
    log_info "Testing all integrations..."
    
    cd "$BACKEND_DIR"
    
    log_step "Testing Google Calendar..."
    python integrations/google_calendar.py --test
    
    log_step "Testing Slack..."
    python integrations/slack_integration.py --test
    
    log_step "Testing Trello..."
    python integrations/trello_integration.py --test
    
    log_info "Integration tests complete!"
}

# Start sync service
start_sync() {
    log_info "Starting integration sync service..."
    cd "$BACKEND_DIR"
    python integrations/sync_service.py --start
}

# Sync specific task
sync_task() {
    local task_id=$1
    if [[ -z "$task_id" ]]; then
        log_warn "Task ID required"
        return 1
    fi
    
    log_info "Syncing task $task_id with all integrations..."
    cd "$BACKEND_DIR"
    python integrations/sync_service.py --manual-sync "$task_id"
}

# Show sync status
sync_status() {
    log_info "Getting sync service status..."
    cd "$BACKEND_DIR"
    python integrations/sync_service.py --status
}

# Show usage
show_usage() {
    echo "Usage: $0 [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  test                    Test all integrations"
    echo "  start-sync             Start background sync service"
    echo "  sync-task <task_id>    Sync specific task"
    echo "  status                 Show sync service status"
    echo ""
    echo "Examples:"
    echo "  $0 test                Test all integration connections"
    echo "  $0 sync-task 123       Sync task 123 with all services"
    echo "  $0 start-sync          Start background sync service"
}

# Main function
main() {
    case "${1:-help}" in
        "test")
            test_integrations
            ;;
        "start-sync")
            start_sync
            ;;
        "sync-task")
            sync_task "$2"
            ;;
        "status")
            sync_status
            ;;
        "help"|*)
            show_usage
            ;;
    esac
}

main "$@"
"""
        
        # Create scripts directory if it doesn't exist
        scripts_dir = self.project_root / "scripts"
        scripts_dir.mkdir(exist_ok=True)
        
        orchestration_file = scripts_dir / "integration_manager.sh"
        with open(orchestration_file, 'w') as f:
            f.write(orchestration_script)
        
        try:
            os.chmod(orchestration_file, 0o755)
        except:
            pass
        
        self.integration_results['sync_services'].append({
            'type': 'Integration Management Script',
            'file': str(orchestration_file),
            'features': 'Test connections, manage sync, task synchronization',
            'usage': './scripts/integration_manager.sh test|start-sync|sync-task|status'
        })
    
    def _create_monitoring_tools(self):
        """Create integration monitoring tools"""
        print("üìä Creating monitoring tools...")
        # Simple monitoring implementation would go here
        pass
    
    def _generate_integration_report(self) -> Dict[str, Any]:
        """Generate comprehensive integration report"""
        
        total_integrations = sum(len(integrations) for integrations in self.integration_results.values())
        
        report = {
            'timestamp': datetime.now().isoformat(),
            'project': 'Email Task Manager',
            'integration_summary': {
                'total_integrations': total_integrations,
                'calendar_integrations': len(self.integration_results['calendar_integrations']),
                'slack_integrations': len(self.integration_results['slack_integrations']),
                'task_manager_integrations': len(self.integration_results['task_manager_integrations']),
                'webhook_handlers': len(self.integration_results['webhook_handlers']),
                'sync_services': len(self.integration_results['sync_services'])
            },
            'integration_components': self.integration_results,
            'supported_services': list(self.supported_integrations.keys()),
            'key_features': [
                "üìÖ Google Calendar task-to-event synchronization",
                "üí¨ Slack notifications with interactive buttons",
                "‚úÖ Trello task management with priority labels",
                "üîó Webhook handling for bidirectional sync",
                "üîÑ Background sync service with error handling",
                "‚öôÔ∏è Centralized integration management",
                "üèóÔ∏è Extensible framework for new integrations"
            ],
            'usage_examples': [
                "./scripts/integration_manager.sh test",
                "./scripts/integration_manager.sh start-sync",
                "./scripts/integration_manager.sh sync-task 123",
                "python integrations/slack_integration.py --daily-summary 1",
                "python integrations/google_calendar.py --sync-task 1"
            ]
        }
        
        # Save report
        report_file = self.project_root / "integration_management_report.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\nüîó Integration Setup Complete!")
        print(f"Total Integrations: {total_integrations}")
        print(f"Supported Services: {len(self.supported_integrations)}")
        print(f"Report saved to: {report_file}")
        
        return report


def main():
    """Main execution function"""
    import sys
    
    project_root = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
    
    manager = EmailTaskIntegrationManager(project_root)
    report = manager.setup_complete_integrations()
    
    # Print summary
    print(f"\n{'='*60}")
    print(f"INTEGRATION SETUP SUMMARY")
    print(f"{'='*60}")
    print(f"Total Integrations: {report['integration_summary']['total_integrations']}")
    print(f"Calendar: {report['integration_summary']['calendar_integrations']}")
    print(f"Slack: {report['integration_summary']['slack_integrations']}")
    print(f"Task Managers: {report['integration_summary']['task_manager_integrations']}")
    print(f"Webhooks: {report['integration_summary']['webhook_handlers']}")
    print(f"Sync Services: {report['integration_summary']['sync_services']}")
    print(f"Supported Services: {', '.join(report['supported_services'])}")
    
    return True


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)